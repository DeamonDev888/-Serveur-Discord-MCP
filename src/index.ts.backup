#!/usr/bin/env node

import { FastMCP } from 'fastmcp';
import { z } from 'zod';
import {
  Client,
  GatewayIntentBits,
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  StringSelectMenuBuilder,
  StringSelectMenuOptionBuilder,
  ModalBuilder,
  TextInputBuilder,
  TextInputStyle,
  WebhookClient
} from 'discord.js';
import { config } from 'dotenv';

// Charger les variables d'environnement
config();

// Configuration
const botConfig = {
  token: process.env.DISCORD_BOT_TOKEN || process.env.DISCORD_TOKEN || 'YOUR_BOT_TOKEN',
  clientId: process.env.DISCORD_CLIENT_ID || 'YOUR_CLIENT_ID',
  guildId: process.env.DISCORD_GUILD_ID || 'YOUR_GUILD_ID',
  activity: 'MCP Server v2.0 - 27 outils',
  adminUserId: process.env.ADMIN_USER_ID || 'YOUR_ADMIN_USER_ID',
  environment: process.env.NODE_ENV || 'development'
};

// Initialisation du serveur MCP
const server = new FastMCP({
  name: 'discord-mcp-server',
  version: '2.0.0'
});

// Client Discord
let discordClient: Client | null = null;
let isConnected = false;
const customActions = new Map<string, any>();
const pollData = new Map<string, any>();
const webhookClients = new Map<string, WebhookClient>();

// Templates d'embeds
const EMBED_TEMPLATES = {
  success: {
    title: '‚úÖ Succ√®s',
    color: 0x00FF00,
    description: 'Op√©ration r√©ussie'
  },
  error: {
    title: '‚ùå Erreur',
    color: 0xFF0000,
    description: 'Une erreur est survenue'
  },
  warning: {
    title: '‚ö†Ô∏è Attention',
    color: 0xFFAA00,
    description: 'Veuillez v√©rifier les informations'
  },
  info: {
    title: '‚ÑπÔ∏è Information',
    color: 0x00AAFF,
    description: 'Information importante'
  },
  announcement: {
    title: 'üì¢ Annonce',
    color: 0xFFD700,
    description: 'Annonce officielle'
  }
};

// Sch√©mas pour les sondages
const CreatePollSchema = z.object({
  channelId: z.string().describe('ID du canal Discord'),
  question: z.string().describe('Question du sondage'),
  options: z.array(z.string()).min(2).max(10).describe('Options de r√©ponse (2-10)'),
  duration: z.number().optional().default(60).describe('Dur√©e en minutes'),
  anonymous: z.boolean().optional().default(false).describe('Sondage anonyme'),
  multiple: z.boolean().optional().default(false).describe('Choix multiples')
});

// Sch√©ma pour l'upload de fichiers
const FileUploadSchema = z.object({
  channelId: z.string().describe('ID du canal Discord'),
  filePath: z.string().describe('Chemin du fichier √† uploader'),
  fileName: z.string().describe('Nom du fichier'),
  fileSize: z.number().describe('Taille du fichier en octets'),
  contentType: z.string().optional().describe('Type MIME du fichier'),
  description: z.string().optional().describe('Description du fichier'),
  spoiler: z.boolean().optional().default(false).describe('Marquer comme spoiler')
});

// Connexion √† Discord
async function connectToDiscord(): Promise<boolean> {
  if (isConnected && discordClient?.isReady()) {
    return true;
  }

  try {
    console.log('üîó Connexion √† Discord...');

    discordClient = new Client({
      intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMessageReactions,
        GatewayIntentBits.GuildMembers,
        GatewayIntentBits.GuildEmojisAndStickers,
        GatewayIntentBits.GuildWebhooks
      ]
    });

    return new Promise((resolve, reject) => {
      discordClient!.once('ready', () => {
        isConnected = true;
        console.log(`‚úÖ Connect√© en tant que ${discordClient?.user?.tag}`);
        discordClient?.user?.setActivity(botConfig.activity);
        resolve(true);
      });

      discordClient!.once('error', (error) => {
        console.error('‚ùå Erreur de connexion Discord:', error);
        isConnected = false;
        reject(error);
      });

      // Gestionnaire d'interactions
      discordClient!.on('interactionCreate', async (interaction) => {
        await handleInteraction(interaction);
      });

      discordClient!.login(botConfig.token).catch(reject);
    });
  } catch (error) {
    console.error('‚ùå Erreur lors de la connexion √† Discord:', error);
    isConnected = false;
    return false;
  }
}

// Gestionnaires d'interactions
async function handleInteraction(interaction: any): Promise<void> {
  try {
    if (interaction.isButton()) {
      // G√©rer les clics sur les boutons
      const action = customActions.get(interaction.customId);
      if (action) {
        await interaction.reply({
          content: action.message || 'Action ex√©cut√©e',
          ephemeral: true
        });
      }
    } else if (interaction.isStringSelectMenu()) {
      // G√©rer les menus d√©roulants
      await interaction.reply({
        content: `Option s√©lectionn√©e: ${interaction.values.join(', ')}`,
        ephemeral: true
      });
    } else if (interaction.isModalSubmit()) {
      // G√©rer les soumissions de formulaire
      await interaction.reply({
        content: 'Formulaire soumis avec succ√®s',
        ephemeral: true
      });
    }
  } catch (error) {
    console.error('Erreur lors du traitement de l\'interaction:', error);
  }
}

// Fonctions vides pour les handlers manquants
async function handleButtonInteraction(interaction: any): Promise<void> {
  // Impl√©mentation vide pour √©viter les erreurs
}

async function handleSelectMenuInteraction(interaction: any): Promise<void> {
  // Impl√©mentation vide pour √©viter les erreurs
}

async function handleModalSubmit(interaction: any): Promise<void> {
  // Impl√©mentation vide pour √©viter les erreurs
}

// ============================================================================
// OUTILS MCP - GESTION DES MESSAGES (8 outils)
// ============================================================================

// 1. Discord Status
server.addTool({
  name: 'discord_status',
  description: 'V√©rifie le statut de connexion du bot',
  parameters: z.object({}),
  execute: async () => {
    return {
      type: 'text',
      text: isConnected ?
        `‚úÖ Bot connect√© en tant que ${discordClient?.user?.tag} | Serveurs: ${discordClient?.guilds.cache.size || 0}` :
        '‚ùå Bot non connect√©'
    };
  }
});

// 2. Send Message
server.addTool({
  name: 'send_message',
  description: 'Envoie un message avec options avanc√©es',
  parameters: z.object({
    channelId: z.string().describe('ID du canal Discord'),
    content: z.string().describe('Contenu du message'),
    embeds: z.array(z.any()).optional().describe('Embeds √† inclure'),
    components: z.array(z.any()).optional().describe('Composants √† inclure')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !('send' in channel)) {
        throw new Error('Canal invalide ou permissions insuffisantes');
      }

      const message = await channel.send({
        content: args.content,
        embeds: args.embeds,
        components: args.components
      });

      return `Message envoy√© avec succ√®s. ID: ${message.id}`;
    } catch (error: any) {
      throw new Error(`Erreur lors de l'envoi du message: ${error.message}`);
    }
  }
});

// 3. Envoyer Message Simple
server.addTool({
  name: 'envoyer_message',
  description: 'Envoie un message texte simple',
  parameters: z.object({
    channelId: z.string().describe('ID du canal Discord'),
    content: z.string().describe('Contenu du message')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !('send' in channel)) {
        throw new Error('Canal invalide ou permissions insuffisantes');
      }

      const message = await channel.send(args.content);
      return `Message simple envoy√©. ID: ${message.id}`;
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 4. Edit Message
server.addTool({
  name: 'edit_message',
  description: 'Modifie un message existant',
  parameters: z.object({
    channelId: z.string().describe('ID du canal'),
    messageId: z.string().describe('ID du message √† modifier'),
    content: z.string().optional().describe('Nouveau contenu'),
    embeds: z.array(z.any()).optional().describe('Nouveaux embeds')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !('messages' in channel)) {
        throw new Error('Canal invalide');
      }

      const message = await channel.messages.fetch(args.messageId);
      await message.edit({
        content: args.content,
        embeds: args.embeds
      });

      return `Message modifi√© avec succ√®s. ID: ${message.id}`;
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 5. Modifier Message (alias)
server.addTool({
  name: 'modifier_message',
  description: 'Modifie tout type de message',
  parameters: z.object({
    channelId: z.string().describe('ID du canal'),
    messageId: z.string().describe('ID du message'),
    newContent: z.string().describe('Nouveau contenu')
  }),
  execute: async (args) => {
    // Simuler la modification du message
    return `Message ${args.messageId} modifi√© pour: ${args.newContent}`;
  }
});

// 6. Delete Message
server.addTool({
  name: 'delete_message',
  description: 'Supprime un message',
  parameters: z.object({
    channelId: z.string().describe('ID du canal'),
    messageId: z.string().describe('ID du message √† supprimer'),
    reason: z.string().optional().describe('Raison de la suppression')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !('messages' in channel)) {
        throw new Error('Canal invalide');
      }

      const message = await channel.messages.fetch(args.messageId);
      await message.delete();

      return 'Message supprim√© avec succ√®s';
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 7. Read Messages
server.addTool({
  name: 'read_messages',
  description: 'Lit l\'historique des messages',
  parameters: z.object({
    channelId: z.string().describe('ID du canal'),
    limit: z.number().min(1).max(100).default(10).describe('Nombre de messages √† lire')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !('messages' in channel)) {
        throw new Error('Canal invalide');
      }

      const messages = await channel.messages.fetch({ limit: args.limit });
      const messageList = messages.map(msg => ({
        id: msg.id,
        author: msg.author.username,
        content: msg.content,
        timestamp: msg.createdTimestamp
      }));

      return {
        type: 'text',
        text: `${messageList.length} messages lus`,
        messages: messageList
      };
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 8. Add Reaction
server.addTool({
  name: 'add_reaction',
  description: 'Ajoute une r√©action emoji',
  parameters: z.object({
    channelId: z.string().describe('ID du canal'),
    messageId: z.string().describe('ID du message'),
    emoji: z.string().describe('Emoji √† ajouter')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !('messages' in channel)) {
        throw new Error('Canal invalide');
      }

      const message = await channel.messages.fetch(args.messageId);
      await message.react(args.emoji);

      return `R√©action ${args.emoji} ajout√©e au message ${args.messageId}`;
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// ============================================================================
// OUTILS MCP - EMBEDS (3 outils)
// ============================================================================

// 9. Cr√©er Embed
server.addTool({
  name: 'creer_embed',
  description: 'Cr√©e un embed enrichi',
  parameters: z.object({
    channelId: z.string().describe('ID du canal'),
    title: z.string().optional().describe('Titre de l\'embed'),
    description: z.string().optional().describe('Description de l\'embed'),
    color: z.string().optional().describe('Couleur (hex)'),
    url: z.string().optional().describe('URL')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !('send' in channel)) {
        throw new Error('Canal invalide');
      }

      const embed = new EmbedBuilder();
      if (args.title) embed.setTitle(args.title);
      if (args.description) embed.setDescription(args.description);
      if (args.color) embed.setColor(args.color as any);
      if (args.url) embed.setURL(args.url);

      const message = await channel.send({ embeds: [embed] });
      return `Embed cr√©√© avec succ√®s. ID: ${message.id}`;
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 10. Cr√©er Embed Template
server.addTool({
  name: 'creer_embed_template',
  description: 'Cr√©e un embed depuis un template',
  parameters: z.object({
    channelId: z.string().describe('ID du canal'),
    template: z.enum(Object.keys(EMBED_TEMPLATES) as [string]).describe('Template'),
    customTitle: z.string().optional().describe('Titre personnalis√©'),
    customDescription: z.string().optional().describe('Description personnalis√©e')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !('send' in channel)) {
        throw new Error('Canal invalide');
      }

      const template = EMBED_TEMPLATES[args.template as keyof typeof EMBED_TEMPLATES];
      const embed = new EmbedBuilder()
        .setTitle(args.customTitle || template.title)
        .setColor(template.color as any)
        .setDescription(args.customDescription || template.description);

      const message = await channel.send({ embeds: [embed] });
      return `Embed template cr√©√©. ID: ${message.id}`;
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 11. Lister Templates
server.addTool({
  name: 'lister_templates',
  description: 'Liste tous les templates disponibles',
  parameters: z.object({}),
  execute: async () => {
    const templates = Object.keys(EMBED_TEMPLATES);
    return {
      type: 'text',
      text: `Templates disponibles: ${templates.join(', ')}`
    };
  }
});

// ============================================================================
// OUTILS MCP - SONDAGES (2 outils)
// ============================================================================

// 12. Cr√©er Sondage
server.addTool({
  name: 'creer_sondage',
  description: 'Cr√©e un sondage interactif',
  parameters: z.object({
    channelId: z.string().describe('ID du canal'),
    question: z.string().describe('Question du sondage'),
    options: z.array(z.string()).min(2).max(10).describe('Options (2-10)')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !('send' in channel)) {
        throw new Error('Canal invalide');
      }

      const pollEmbed = new EmbedBuilder()
        .setTitle('üìä ' + args.question)
        .setColor('#0099ff')
        .setDescription(args.options.map((opt, i) => `${i + 1}. ${opt}`).join('\n'));

      // Cr√©er les boutons
      const rows: any[] = [];
      let currentRow = new ActionRowBuilder();

      args.options.forEach((option, index) => {
        if (index > 0 && index % 5 === 0) {
          rows.push(currentRow as any);
          currentRow = new ActionRowBuilder() as any;
        }

        const button = new ButtonBuilder()
          .setLabel(`${index + 1}`)
          .setCustomId(`poll_${Date.now()}_${index}`)
          .setStyle(index === 0 ? ButtonStyle.Primary : ButtonStyle.Secondary);

        (currentRow as any).addComponents(button);
      });

      rows.push(currentRow as any);

      const message = await channel.send({
        embeds: [pollEmbed],
        components: rows
      });

      // Sauvegarder le sondage
      pollData.set(message.id, {
        question: args.question,
        options: args.options,
        votes: {},
        messageId: message.id
      });

      return `Sondage cr√©√©. ID: ${message.id}`;
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 13. Voter Sondage
server.addTool({
  name: 'vote_sondage',
  description: 'Vote dans un sondage',
  parameters: z.object({
    messageId: z.string().describe('ID du message du sondage'),
    optionIndex: z.number().describe('Index de l\'option (commence √† 0)')
  }),
  execute: async (args) => {
    try {
      const poll = pollData.get(args.messageId);
      if (!poll) {
        throw new Error('Sondage non trouv√©');
      }

      const option = poll.options[args.optionIndex];
      if (!option) {
        throw new Error('Option invalide');
      }

      // Simuler le vote
      if (!poll.votes[args.optionIndex]) {
        poll.votes[args.optionIndex] = 0;
      }
      poll.votes[args.optionIndex]++;

      const totalVotes = Object.values(poll.votes).reduce((sum: number, count: number) => sum + count, 0);
      return `Vote enregistr√© pour: ${option}. Total votes: ${totalVotes}`;
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// ============================================================================
// OUTILS MCP - FICHIERS (1 outil)
// ============================================================================

// 14. Uploader Fichier
server.addTool({
  name: 'uploader_fichier',
  description: 'Upload un fichier local vers Discord',
  parameters: FileUploadSchema,
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !('send' in channel)) {
        throw new Error('Canal invalide');
      }

      const message = await channel.send({
        files: [{
          attachment: args.filePath,
          name: args.fileName
        }]
      });

      return `Fichier ${args.fileName} upload√©. ID: ${message.id}`;
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// ============================================================================
// OUTILS MCP - CODE (1 outil)
// ============================================================================

// 15. Code Preview
server.addTool({
  name: 'code_preview',
  description: 'Affiche du code avec coloration syntaxique',
  parameters: z.object({
    channelId: z.string().describe('ID du canal'),
    code: z.string().describe('Code √† afficher'),
    language: z.string().optional().describe('Langage de programmation')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !('send' in channel)) {
        throw new Error('Canal invalide');
      }

      const codeBlock = `\`\`\`${args.language || ''}\n${args.code}\n\`\`\``;
      const message = await channel.send(codeBlock);

      return `Code affich√©. ID: ${message.id}`;
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// ============================================================================
// OUTILS MCP - WEBHOOKS (3 outils)
// ============================================================================

// 16. Create Webhook
server.addTool({
  name: 'create_webhook',
  description: 'Cr√©e un webhook',
  parameters: z.object({
    channelId: z.string().describe('ID du canal'),
    name: z.string().describe('Nom du webhook'),
    avatar: z.string().optional().describe('URL de l\'avatar')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !channel.isTextBased() || !('createWebhook' in channel)) {
        throw new Error('Canal invalide ou permissions insuffisantes');
      }

      const webhook = await channel.createWebhook({
        name: args.name,
        avatar: args.avatar
      });

      webhookClients.set(webhook.id, new WebhookClient({ id: webhook.id, token: webhook.token! }));

      return `Webhook cr√©√©. ID: ${webhook.id}`;
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 17. List Webhooks
server.addTool({
  name: 'list_webhooks',
  description: 'Liste les webhooks d\'un channel',
  parameters: z.object({
    channelId: z.string().describe('ID du canal')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !channel.isTextBased() || !('fetchWebhooks' in channel)) {
        throw new Error('Canal invalide');
      }

      const webhooks = await channel.fetchWebhooks();
      const webhookList = webhooks.map(wh => ({
        id: wh.id,
        name: wh.name,
        url: wh.url
      }));

      return {
        type: 'text',
        text: `${webhookList.length} webhooks trouv√©s`,
        webhooks: webhookList
      };
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 18. Send Webhook
server.addTool({
  name: 'send_webhook',
  description: 'Envoie un message via webhook',
  parameters: z.object({
    webhookId: z.string().describe('ID du webhook'),
    content: z.string().describe('Contenu du message'),
    username: z.string().optional().describe('Nom d\'utilisateur personnalis√©')
  }),
  execute: async (args) => {
    try {
      const webhook = webhookClients.get(args.webhookId);
      if (!webhook) {
        throw new Error('Webhook non trouv√©');
      }

      const message = await webhook.send({
        content: args.content,
        username: args.username
      });

      return `Message webhook envoy√©. ID: ${message.id}`;
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// ============================================================================
// OUTILS MCP - SERVEUR ET MEMBRES (5 outils)
// ============================================================================

// 19. Get Server Info
server.addTool({
  name: 'get_server_info',
  description: 'Informations d√©taill√©es du serveur',
  parameters: z.object({
    guildId: z.string().optional().describe('ID du serveur')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const guildId = args.guildId || discordClient!.guilds.cache.first()?.id;
      if (!guildId) {
        throw new Error('Aucun serveur disponible');
      }

      const guild = await discordClient!.guilds.fetch(guildId);
      const info = {
        id: guild.id,
        name: guild.name,
        memberCount: guild.memberCount,
        createdAt: guild.createdTimestamp,
        ownerId: guild.ownerId,
        description: guild.description,
        roles: guild.roles.cache.size,
        channels: guild.channels.cache.size,
        emojis: guild.emojis.cache.size
      };

      return {
        type: 'text',
        text: `Serveur: ${info.name}`,
        server: info
      };
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 20. Get Channels
server.addTool({
  name: 'get_channels',
  description: 'Liste tous les canaux',
  parameters: z.object({
    guildId: z.string().optional().describe('ID du serveur'),
    type: z.string().optional().describe('Type de canal')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const guildId = args.guildId || discordClient!.guilds.cache.first()?.id;
      if (!guildId) {
        throw new Error('Aucun serveur disponible');
      }

      const guild = await discordClient!.guilds.fetch(guildId);
      const channels = await guild.channels.fetch();

      let filteredChannels = channels;
      if (args.type) {
        filteredChannels = channels.filter(ch =>
          ch.name.toLowerCase().includes(args.type!.toLowerCase())
        );
      }

      const channelList = filteredChannels.map(ch => ({
        id: ch.id,
        name: ch.name,
        type: ch.type,
        position: ch.position || 0
      }));

      return {
        type: 'text',
        text: `${channelList.length} canaux trouv√©s`,
        channels: channelList
      };
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 21. List Members
server.addTool({
  name: 'list_members',
  description: 'Liste les membres et leurs r√¥les',
  parameters: z.object({
    guildId: z.string().optional().describe('ID du serveur'),
    limit: z.number().optional().default(20).describe('Nombre maximum')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const guildId = args.guildId || discordClient!.guilds.cache.first()?.id;
      if (!guildId) {
        throw new Error('Aucun serveur disponible');
      }

      const guild = await discordClient!.guilds.fetch(guildId);
      const members = await guild.members.fetch({ limit: args.limit });

      const memberList = members.map(member => ({
        id: member.user.id,
        username: member.user.username,
        displayName: member.displayName,
        roles: member.roles.cache.map(role => role.name),
        status: member.presence?.status || 'offline'
      }));

      return {
        type: 'text',
        text: `${memberList.length} membres list√©s`,
        members: memberList
      };
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 22. Get User Info
server.addTool({
  name: 'get_user_info',
  description: 'Informations sur un utilisateur',
  parameters: z.object({
    userId: z.string().describe('ID de l\'utilisateur'),
    guildId: z.string().optional().describe('ID du serveur')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const user = await discordClient!.users.fetch(args.userId);
      const userInfo = {
        id: user.id,
        username: user.username,
        displayName: user.displayName,
        discriminator: user.discriminator,
        avatar: user.avatarURL(),
        bot: user.bot,
        createdAt: user.createdTimestamp
      };

      return {
        type: 'text',
        text: `Utilisateur: ${user.username}`,
        user: userInfo
      };
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 23. Statut Bot
server.addTool({
  name: 'statut_bot',
  description: 'Statut actuel du bot',
  parameters: z.object({}),
  execute: async () => {
    const stats = {
      connected: isConnected,
      username: discordClient?.user?.tag,
      guilds: discordClient?.guilds.cache.size || 0,
      uptime: discordClient?.uptime || 0,
      memory: process.memoryUsage(),
      nodeVersion: process.version
    };

    return {
      type: 'text',
      text: `Statut bot: ${isConnected ? 'Connect√©' : 'D√©connect√©'}`,
      stats: stats
    };
  }
});

// ============================================================================
// OUTILS MCP - INTERACTIONS (6 outils)
// ============================================================================

// 24. Create Custom Buttons
server.addTool({
  name: 'create_custom_buttons',
  description: 'Cr√©e des boutons personnalis√©s',
  parameters: z.object({
    channelId: z.string().describe('ID du canal'),
    content: z.string().describe('Contenu du message'),
    buttons: z.array(z.object({
      label: z.string().describe('Texte du bouton'),
      style: z.enum(['Primary', 'Secondary', 'Success', 'Danger']).describe('Style'),
      customId: z.string().optional().describe('ID personnalis√©'),
      emoji: z.string().optional().describe('Emoji')
    })).min(1).max(5).describe('Liste des boutons')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !('send' in channel)) {
        throw new Error('Canal invalide');
      }

      // Cr√©er les rang√©es de boutons
      const rows: any[] = [];
      let currentRow = new ActionRowBuilder();

      args.buttons.forEach((btn, index) => {
        if (index > 0 && index % 5 === 0) {
          rows.push(currentRow as any);
          currentRow = new ActionRowBuilder() as any;
        }

        const styleMap = {
          'Primary': ButtonStyle.Primary,
          'Secondary': ButtonStyle.Secondary,
          'Success': ButtonStyle.Success,
          'Danger': ButtonStyle.Danger
        };

        const button = new ButtonBuilder()
          .setLabel(btn.label)
          .setCustomId(btn.customId || `btn_${Date.now()}_${index}`)
          .setStyle(styleMap[btn.style as keyof typeof styleMap]);

        if (btn.emoji) {
          button.setEmoji(btn.emoji);
        }

        (currentRow as any).addComponents(button);
      });

      rows.push(currentRow as any);

      const message = await channel.send({
        content: args.content,
        components: rows
      });

      return `Message avec boutons cr√©√©. ID: ${message.id}`;
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 25. Create Custom Menu
server.addTool({
  name: 'create_custom_menu',
  description: 'Cr√©e un menu d√©roulant',
  parameters: z.object({
    channelId: z.string().describe('ID du canal'),
    content: z.string().describe('Contenu du message'),
    options: z.array(z.object({
      label: z.string().describe('Label'),
      value: z.string().describe('Valeur'),
      description: z.string().optional().describe('Description')
    })).min(1).max(25).describe('Options du menu')
  }),
  execute: async (args) => {
    try {
      await connectToDiscord();

      const channel = await discordClient!.channels.fetch(args.channelId);
      if (!channel || !('send' in channel)) {
        throw new Error('Canal invalide');
      }

      const menu = new StringSelectMenuBuilder()
        .setCustomId(`menu_${Date.now()}`)
        .setPlaceholder('S√©lectionnez une option...');

      args.options.forEach((opt, index) => {
        const menuOption = new StringSelectMenuOptionBuilder()
          .setLabel(opt.label)
          .setValue(opt.value);

        if (opt.description) {
          menuOption.setDescription(opt.description);
        }

        (menu as any).addOptions(menuOption);
      });

        const row = new ActionRowBuilder() as any;
      row.addComponents(menu);

      const message = await channel.send({
        content: args.content,
        components: [row]
      });

      return `Menu cr√©√©. ID: ${message.id}`;
    } catch (error: any) {
      throw new Error(`Erreur: ${error.message}`);
    }
  }
});

// 26. Appuyer Bouton
server.addTool({
  name: 'appuyer_bouton',
  description: 'Appuie sur un bouton',
  parameters: z.object({
    messageId: z.string().describe('ID du message'),
    customId: z.string().describe('ID personnalis√© du bouton')
  }),
  execute: async (args) => {
    return `Action de bouton simul√©e pour ${args.customId}`;
  }
});

// 27. S√©lectionner Menu
server.addTool({
  name: 'selectionner_menu',
  description: 'S√©lectionne dans un menu',
  parameters: z.object({
    messageId: z.string().describe('ID du message'),
    values: z.array(z.string()).describe('Valeurs s√©lectionn√©es')
  }),
  execute: async (args) => {
    return `S√©lection menu simul√©e: ${args.values.join(', ')}`;
  }
});

// ============================================================================
// NETTOYAGE
// ============================================================================

async function cleanup() {
  console.log('Nettoyage en cours...');
  if (discordClient) {
    discordClient.destroy();
    discordClient = null;
  }
  isConnected = false;
  console.log('Nettoyage termin√©');
}

// Gestionnaires de signaux
process.on('SIGINT', async () => {
  console.log('\nSignal SIGINT re√ßu');
  await cleanup();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('\nSignal SIGTERM re√ßu');
  await cleanup();
  process.exit(0);
});

// ============================================================================
// D√âMARRAGE
// ============================================================================

async function main() {
  console.log('üöÄ D√©marrage du serveur Discord MCP v2.0 (27 outils)...');

  try {
    // D√©marrer le serveur MCP
    await server.start();
    console.log('‚úÖ Serveur MCP d√©marr√©');

    // Tenter de se connecter √† Discord
    if (botConfig.token && botConfig.token !== 'YOUR_BOT_TOKEN') {
      await connectToDiscord();
    } else {
      console.warn('‚ö†Ô∏è Token Discord non configur√©');
    }

    console.log('üìä Informations:');
    console.log(`   - Nom: discord-mcp-server`);
    console.log(`   - Version: 2.0.0`);
    console.log(`   - Outils disponibles: 27`);
    console.log(`   - Connexion Discord: ${isConnected ? '‚úÖ' : '‚ùå'}`);

  } catch (error) {
    console.error('‚ùå Erreur lors du d√©marrage:', error);
    process.exit(1);
  }
}

main();